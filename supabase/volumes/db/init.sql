-- ====================================================================================
-- SCRIPT DE INICIALIZAÇÃO COMPLETO DO BANCO DE DADOS
-- Este arquivo contém toda a estrutura, tabelas, funções e políticas de segurança.
-- ====================================================================================

-- 1. CRIAÇÃO DE TIPOS E TABELAS
-- ====================================================================================

-- Criação do tipo ENUM para os perfis de utilizador
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role') THEN
        CREATE TYPE public.user_role AS ENUM ('admin', 'caixa', 'garcom', 'customer', 'cozinha');
    ELSE
        -- Adiciona o novo valor se o tipo já existir, para não dar erro em re-execuções
        ALTER TYPE public.user_role ADD VALUE IF NOT EXISTS 'cozinha';
    END IF;
END$$;

-- Tabela de Categorias
CREATE TABLE public.categories (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Tabela de Produtos
CREATE TABLE public.products (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    price NUMERIC NOT NULL,
    image_url TEXT,
    category_id BIGINT REFERENCES public.categories(id) ON DELETE SET NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    is_on_sale BOOLEAN DEFAULT false,
    sale_price NUMERIC
);

-- Tabela de Pedidos
CREATE TABLE public.orders (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id),
    total_price NUMERIC NOT NULL,
    status TEXT DEFAULT 'pending'::text, -- pending, accepted, ready, delivered, cancelled
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    delivery_type TEXT DEFAULT 'delivery'::text,
    payment_method TEXT,
    change_for TEXT,
    payment_status TEXT DEFAULT 'pending'::text,
    in_person_identifier TEXT
);

-- Tabela de Itens do Pedido
CREATE TABLE public.order_items (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    order_id BIGINT REFERENCES public.orders(id) ON DELETE CASCADE NOT NULL,
    product_id BIGINT REFERENCES public.products(id) ON DELETE SET NULL,
    quantity INTEGER NOT NULL,
    price NUMERIC NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Tabela de Perfis de Utilizadores
CREATE TABLE public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users ON DELETE CASCADE,
    full_name TEXT,
    email TEXT UNIQUE,
    role public.user_role DEFAULT 'customer'::public.user_role,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    cep TEXT,
    address TEXT,
    number TEXT,
    neighborhood TEXT,
    complement TEXT,
    cpf TEXT,
    phone TEXT,
    accepts_communications BOOLEAN DEFAULT false
);

-- Tabela de Configurações da Loja
CREATE TABLE public.store_settings (
    id BIGINT PRIMARY KEY,
    store_name TEXT,
    store_address TEXT,
    phone_number TEXT,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    delivery_fee NUMERIC DEFAULT 0,
    delivery_time_estimate TEXT,
    show_promotions_section BOOLEAN DEFAULT true,
    logo_url TEXT,
    primary_color TEXT DEFAULT '#f59e0b',
    secondary_color TEXT DEFAULT '#4f46e5',
    whatsapp_instance_name TEXT,
    whatsapp_status_template TEXT DEFAULT 'Olá {cliente}! O estado do seu pedido #{pedido} foi atualizado para: *{status}*.',
    whatsapp_promo_template TEXT DEFAULT 'Olá {cliente}! Nova promoção imperdível: *{promocao}* por apenas *{preco_promocional}*! Peça já a sua.',
    CONSTRAINT singleton_check CHECK (id = 1)
);

-- Tabela de Promoções (Banners)
CREATE TABLE public.promotions (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    title TEXT,
    image_url TEXT NOT NULL,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 2. FUNÇÕES E TRIGGERS
-- ====================================================================================

-- Função para criar um perfil automaticamente após o registo de um novo utilizador
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.profiles (id, full_name, email, role)
    VALUES (new.id, new.raw_user_meta_data->>'full_name', new.email, (new.raw_user_meta_data->>'role')::public.user_role);
    RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger para executar a função acima
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();


-- 3. HABILITAÇÃO DO RLS (ROW-LEVEL SECURITY)
-- ====================================================================================
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.order_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.store_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.promotions ENABLE ROW LEVEL SECURITY;


-- 4. POLÍTICAS DE SEGURANÇA (POLICIES)
-- ====================================================================================

-- Policies para 'profiles'
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Allow admins to read all user profiles" ON public.profiles FOR SELECT USING ( (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'::public.user_role );
CREATE POLICY "Allow admins to update any user profile" ON public.profiles FOR UPDATE USING ( (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'::public.user_role ) WITH CHECK ( (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'::public.user_role );

-- Policies para 'products' e 'categories' (leitura pública)
CREATE POLICY "Public can read products" ON public.products FOR SELECT USING (true);
CREATE POLICY "Public can read categories" ON public.categories FOR SELECT USING (true);
CREATE POLICY "Admins can manage products" ON public.products FOR ALL USING ( (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'::public.user_role );
CREATE POLICY "Admins can manage categories" ON public.categories FOR ALL USING ( (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'::public.user_role );

-- Policies para 'orders' e 'order_items'
CREATE POLICY "Users can manage their own orders" ON public.orders FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Staff can view all orders" ON public.orders FOR SELECT USING ( (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('admin'::public.user_role, 'caixa'::public.user_role, 'cozinha'::public.user_role) );
CREATE POLICY "Staff can update orders" ON public.orders FOR UPDATE USING ( (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('admin'::public.user_role, 'caixa'::public.user_role, 'cozinha'::public.user_role) );
CREATE POLICY "Users can manage their own order items" ON public.order_items FOR ALL USING (auth.uid() = (SELECT user_id FROM orders WHERE id = order_id));
CREATE POLICY "Staff can view all order items" ON public.order_items FOR SELECT USING ( (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('admin'::public.user_role, 'caixa'::public.user_role, 'cozinha'::public.user_role) );

-- Policies para 'store_settings'
CREATE POLICY "Public can read store settings" ON public.store_settings FOR SELECT USING (true);
CREATE POLICY "Admins can insert store settings" ON public.store_settings FOR INSERT WITH CHECK ( (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'::public.user_role );
CREATE POLICY "Admins can update store settings" ON public.store_settings FOR UPDATE USING ( (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'::public.user_role );

-- Policies para 'promotions'
CREATE POLICY "Public can read active promotions" ON public.promotions FOR SELECT USING (is_active = true);
CREATE POLICY "Admins can manage promotions" ON public.promotions FOR ALL USING ( (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'::public.user_role );


-- 5. STORAGE E POLÍTICAS DE STORAGE
-- ====================================================================================

-- Criação dos Buckets
INSERT INTO storage.buckets (id, name, public) VALUES ('product-images', 'product-images', true) ON CONFLICT (id) DO NOTHING;
INSERT INTO storage.buckets (id, name, public) VALUES ('logos', 'logos', true) ON CONFLICT (id) DO NOTHING;
INSERT INTO storage.buckets (id, name, public) VALUES ('promotion-banners', 'promotion-banners', true) ON CONFLICT (id) DO NOTHING;

-- Policies para 'product-images'
CREATE POLICY "Public read access for product images" ON storage.objects FOR SELECT USING ( bucket_id = 'product-images' );
CREATE POLICY "Allow admins to manage product images" ON storage.objects FOR ALL USING ( bucket_id = 'product-images' AND (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'::public.user_role );

-- Policies para 'logos'
CREATE POLICY "Public read access for logos" ON storage.objects FOR SELECT USING ( bucket_id = 'logos' );
CREATE POLICY "Allow admins to manage logos" ON storage.objects FOR ALL USING ( bucket_id = 'logos' AND (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'::public.user_role );

-- Policies para 'promotion-banners'
CREATE POLICY "Public read access for promotion banners" ON storage.objects FOR SELECT USING ( bucket_id = 'promotion-banners' );
CREATE POLICY "Allow admins to manage promotion banners" ON storage.objects FOR ALL USING ( bucket_id = 'promotion-banners' AND (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'::public.user_role );


-- 6. DADOS INICIAIS
-- ====================================================================================
INSERT INTO public.store_settings (id, store_name) VALUES (1, 'Sabor Digital') ON CONFLICT (id) DO NOTHING;

-- ====================================================================================
-- 7. TABELAS PARA O CHAT DO WHATSAPP
-- ====================================================================================

-- Tabela para guardar o estado da conexão do Baileys
CREATE TABLE public.whatsapp_connections (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    session_id TEXT NOT NULL DEFAULT 'default',
    connection_status TEXT,
    last_qr TEXT,
    connected_number TEXT,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.whatsapp_connections ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admin access to connections" ON public.whatsapp_connections FOR ALL USING ( (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'::public.user_role );

-- Tabela para as conversas (chats)
CREATE TABLE public.whatsapp_chats (
    id TEXT PRIMARY KEY, -- O JID (ex: 5511999998888@s.whatsapp.net)
    name TEXT,
    unread_count INT DEFAULT 0,
    last_message_timestamp TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.whatsapp_chats ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admin access to chats" ON public.whatsapp_chats FOR ALL USING ( (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'::public.user_role );

-- Tabela para as mensagens
CREATE TABLE public.whatsapp_messages (
    id TEXT PRIMARY KEY, -- O ID da mensagem do WhatsApp
    chat_id TEXT REFERENCES public.whatsapp_chats(id) ON DELETE CASCADE,
    sender_id TEXT,
    message_type TEXT,
    message_body TEXT,
    sent_by_us BOOLEAN DEFAULT false,
    "timestamp" TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.whatsapp_messages ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admin access to messages" ON public.whatsapp_messages FOR ALL USING ( (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'::public.user_role );

-- Habilitar notificações em tempo real para as novas tabelas
ALTER PUBLICATION supabase_realtime ADD TABLE public.whatsapp_chats;
ALTER PUBLICATION supabase_realtime ADD TABLE public.whatsapp_messages;

-- ====================================================================================
-- 8. TABELA PARA CONFIGURAÇÕES DO WHATSAPP
-- ====================================================================================

-- ====================================================================================
-- 8. TABELA PARA CONFIGURAÇÕES DO WHATSAPP
-- ====================================================================================

CREATE TABLE public.whatsapp_settings (
    id BIGINT PRIMARY KEY DEFAULT 1,
    send_order_updates BOOLEAN DEFAULT true,
    send_promotions BOOLEAN DEFAULT true,
    process_group_messages BOOLEAN DEFAULT false, -- <-- NOVA COLUNA
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    CONSTRAINT singleton_check CHECK (id = 1)
);
ALTER TABLE public.whatsapp_settings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admin access to whatsapp settings" ON public.whatsapp_settings FOR ALL USING ( (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'::public.user_role );

-- Insere a linha de configuração padrão com o novo valor
INSERT INTO public.whatsapp_settings (id, send_order_updates, process_group_messages) VALUES (1, true, false) ON CONFLICT (id) DO UPDATE 
SET 
    send_order_updates = EXCLUDED.send_order_updates,
    process_group_messages = EXCLUDED.process_group_messages;